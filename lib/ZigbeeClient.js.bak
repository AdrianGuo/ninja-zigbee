// Required libraries/interfaces/classes
var util = require('util');
var Stream = require('stream');
var ZigbeeDevice = require(__dirname+'/ZigbeeDevice');

// Extend ZigBeeClient class with Stream
util.inherits(ZigBeeClient,Stream);

// Export the ZigBeeClient class
module.exports = ZigBeeClient;


var DEVICES = {};

var ZllDeviceIdx = 1;
var ZigBeeDeviceIdx = 1;

//SRPC header bit positions
var SRPC_CMD_ID_POS = 0;
var SRPC_CMD_LEN_POS = 1;

//SRPC CMD ID's
//define the outgoing (from server) RPSC command ID's
var RPCS_NEW_ZLL_DEVICE     = 0x0001;
var RPCS_DEV_ANNCE          = 0x0002;
var RPCS_SIMPLE_DESC        = 0x0003;
var RPCS_TEMP_READING       = 0x0004;
var RPCS_POWER_READING      = 0x0005;
var RPCS_PING               = 0x0006;
var RPCS_GET_DEV_STATE_RSP  = 0x0007;
var RPCS_GET_DEV_LEVEL_RSP  = 0x0008;
var RPCS_GET_DEV_HUE_RSP    = 0x0009;
var RPCS_GET_DEV_SAT_RSP    = 0x000a;
var RPCS_ADD_GROUP_RSP      = 0x000b;
var RPCS_GET_GROUP_RSP      = 0x000c;
var RPCS_ADD_SCENE_RSP      = 0x000d;
var RPCS_GET_SCENE_RSP      = 0x000e;
var RPCS_HUMID_READING      = 0x000f;
var RPCS_ZONESTATE_CHANGE   = 0x0010;

//define incoming (to server) RPCS command ID's
var RPCS_CLOSE              = 0x80;
var RPCS_GET_DEVICES        = 0x81;
var RPCS_SET_DEV_STATE      = 0x82;
var RPCS_SET_DEV_LEVEL      = 0x83;
var RPCS_SET_DEV_COLOR      = 0x84;
var RPCS_GET_DEV_STATE      = 0x85;
var RPCS_GET_DEV_LEVEL      = 0x86;
var RPCS_GET_DEV_HUE        = 0x87;
var RPCS_GET_DEV_SAT        = 0x88;
var RPCS_BIND_DEVICES       = 0x89;
var RPCS_GET_THERM_READING  = 0x8a;
var RPCS_GET_POWER_READING  = 0x8b;
var RPCS_DISCOVER_DEVICES   = 0x8c;
var RPCS_SEND_ZCL           = 0x8d;
var RPCS_GET_GROUPS         = 0x8e;
var RPCS_ADD_GROUP          = 0x8f;
var RPCS_GET_SCENES         = 0x90;
var RPCS_STORE_SCENE        = 0x91;
var RPCS_RECALL_SCENE       = 0x92;
var RPCS_IDENTIFY_DEVICE    = 0x93;
var RPCS_CHANGE_DEVICE_NAME = 0x94;
var RPCS_REMOVE_DEVICE      = 0x95;

//SRPC AfAddr Addr modes ID's
var AddrNotPresent = 0;
var AddrGroup = 1;
var Addr16Bit = 2;
var Addr64Bit = 3;
var AddrBroadcast = 1;

/**
 * Creates a new Zigbee Client
 *
 * @class Represents a Zigbee Client
 */
function ZigBeeClient(logger) {
  this.writable = true;
  this.readable = true;
  this.log = logger;
};

/**
 * Handles the interation over the data received
 * from the SRPC connection.
 *
 * @param  {String} data Data received from the SRPC
 */
ZigBeeClient.prototype.write = function(data) {
  var bytesRead = data.length;
  var bytesProcessed = 0;

  while (bytesRead > bytesProcessed) {
    this.log.debug('ZigBeeClient.prototype.write: processing msg');
    bytesProcessed += this.processData(data, bytesProcessed);
  }
};

/**
 * Processes the data received from the SRPC connection.
 *
 * @param  {String} msg    Data received
 * @param  {Number} msgPtr Number of bytes processed
 * @fires ZigbeeClient#device instance of ZigbeeDevice on new device found.
 */
ZigBeeClient.prototype.processData = function(msg, msgPtr) {
  debugger;
  var msgLen=0;
  var self = this;

  this.log.debug('ZigBeeClient.prototype.processData: '+msg[msgPtr + SRPC_CMD_ID_POS]);
  switch (msg[msgPtr + SRPC_CMD_ID_POS]) {

    case RPCS_NEW_ZLL_DEVICE:
      msgLen = msg[msgPtr + SRPC_CMD_LEN_POS] + 2;    
      self.processNewDevice(msg, msgPtr);      
      
      break;

    //TODO: deal with these and update the color shown on color picker
    case RPCS_GET_DEV_LEVEL_RSP:

      var nwkAddr=0;
      var endPoint;

      msgLen = msg[msgPtr + SRPC_CMD_LEN_POS] + 2;
      //index passed len, cmd ID and status
      msgPtr+=2;

      //Get the NwkAddr
      for (var i=0; i < 2; i++, msgPtr++) {
        //javascript does not support unsigned so use a bigger container
        //to avoid conversion issues
        var nwkAddrTemp = (msg[msgPtr] & 0xff);
        nwkAddr += (nwkAddrTemp << (8 * i));
      }

      //Get the EndPoint
      endPoint = msg[msgPtr++];

      var lvl = msg[msgPtr++];

      var thisZigbeeDevice = DEVICES[nwkAddr.toString()+endPoint.toString()+RPCS_GET_DEV_LEVEL_RSP];

      if(thisZigbeeDevice) {
        thisZigbeeDevice.ninja.emit('data',JSON.stringify({bri:lvl}))
      };

      break;
    //TODO: deal with these and update the color shown on color picker
    case RPCS_POWER_READING:

      var nwkAddr=0;
      var endPoint;      

      msgLen = msg[msgPtr + SRPC_CMD_LEN_POS] + 2;
      //index passed len, cmd ID and status
      msgPtr+=2;

      //Get the NwkAddr
      for (var i=0; i < 2; i++, msgPtr++) {
        //javascript does not support unsigned so use a bigger container
        //to avoid conversion issues
        var nwkAddrTemp = (msg[msgPtr] & 0xff);
        nwkAddr += (nwkAddrTemp << (8 * i));
      }
      this.log.debug('ZigBeeClient.prototype.processData[RPCS_GET_POWER_READING]: nwkAddr ' +nwkAddr);
       
      //Get the EndPoint
      endPoint = msg[msgPtr++];
      this.log.debug('ZigBeeClient.prototype.processData[RPCS_GET_POWER_READING]: endPoint ' +endPoint);

      //Get the power
      var power=0;
      for (var i=0; i < 4; i++, msgPtr++) {
        //javascript does not support unsigned so use a bigger container
        //to avoid conversion issues
        var powerTemp = (msg[msgPtr] & 0xff);
        power += (powerTemp << (8 * i));
        this.log.debug('ZigBeeClient.prototype.processData[RPCS_GET_POWER_READING]: power: ' +power +' powerTemp:' +powerTemp);
      }            
      power = power/100;
      
      var thisZigbeeDevice = DEVICES[nwkAddr.toString()+endPoint.toString()+RPCS_POWER_READING];      

      if(thisZigbeeDevice) {
        this.log.info('emitting power data for ZigbeeDevice: ' +thisZigbeeDevice.nwkAddr +':' +thisZigbeeDevice.endPoint +':' +power );
        thisZigbeeDevice.ninja.emit('data',power.toString())       
      }
      else
      {
        this.log.info('ZigBeeClient.prototype.processData[RPCS_GET_POWER_READING]: ZigbeeDevice not defined.');
      };
      break;
      
   case RPCS_HUMID_READING:

      var nwkAddr=0;
      var endPoint;      

      msgLen = msg[msgPtr + SRPC_CMD_LEN_POS] + 2;
      //index passed len, cmd ID and status
      msgPtr+=2;

      //Get the NwkAddr
      for (var i=0; i < 2; i++, msgPtr++) {
        //javascript does not support unsigned so use a bigger container
        //to avoid conversion issues
        var nwkAddrTemp = (msg[msgPtr] & 0xff);
        nwkAddr += (nwkAddrTemp << (8 * i));
      }
      this.log.debug('ZigBeeClient.prototype.processData[RPCS_HUMID_READING]: nwkAddr ' +nwkAddr);
       
      //Get the EndPoint
      endPoint = msg[msgPtr++];
      this.log.debug('ZigBeeClient.prototype.processData[RPCS_HUMID_READING]: endPoint ' +endPoint);

      //Get the Humidity
      var Humidity=0;      
      for (var i=0; i < 2; i++, msgPtr++) {
        //javascript does not support unsigned so use a bigger container
        //to avoid conversion issues
        var HumidityTemp = (msg[msgPtr] & 0xff);
        Humidity += (HumidityTemp << (8 * i));
      }           

      //MeasuredValue represents the relative humidity in % as follows:-
      //MeasuredValue = 100 x Relative humidity
      //Where 0% <= Relative humidity <= 100%, corresponding to a MeasuredValue in
      //the range 0 to 0x2710.
      //The maximum resolution this format allows is 0.01%.
      Humidity = Humidity/100;
      
      var thisZigbeeDevice = DEVICES[nwkAddr.toString()+endPoint.toString()+RPCS_HUMID_READING];      

      if(thisZigbeeDevice) {
        this.log.info('emitting humidity data for ZigbeeDevice: ' +thisZigbeeDevice.nwkAddr +':' +thisZigbeeDevice.endPoint +' tempDegC:' +Humidity);
        thisZigbeeDevice.ninja.emit('data',Humidity.toString())       
      }
      else
      {
        this.log.info('ZigBeeClient.prototype.processData[RPCS_HUMID_READING]: ZigbeeDevice ' +nwkAddr.toString()+endPoint.toString()+RPCS_HUMID_READING +' not defined.');
      };
      break;      
      
   case RPCS_TEMP_READING:

      var nwkAddr=0;
      var endPoint;      

      msgLen = msg[msgPtr + SRPC_CMD_LEN_POS] + 2;
      //index passed len, cmd ID and status
      msgPtr+=2;

      //Get the NwkAddr
      for (var i=0; i < 2; i++, msgPtr++) {
        //javascript does not support unsigned so use a bigger container
        //to avoid conversion issues
        var nwkAddrTemp = (msg[msgPtr] & 0xff);
        nwkAddr += (nwkAddrTemp << (8 * i));
      }
      this.log.debug('ZigBeeClient.prototype.processData[RPCS_TEMP_READING]: nwkAddr ' +nwkAddr);
       
      //Get the EndPoint
      endPoint = msg[msgPtr++];
      this.log.debug('ZigBeeClient.prototype.processData[RPCS_TEMP_READING]: endPoint ' +endPoint);

      //Get the temp
      var tempDegC=0;      
      for (var i=0; i < 2; i++, msgPtr++) {
        //javascript does not support unsigned so use a bigger container
        //to avoid conversion issues
        var tempDegCTemp = (msg[msgPtr] & 0xff);
        tempDegC += (tempDegCTemp << (8 * i));
      }
           
      //ZigBee temp reading is in DegC * 100 
      //(Where -273.15°C <= temperature <= 327.67 ºC, corresponding to a
      //MeasuredValue in the range 0x954d to 0x7fff. The maximum resolution this
      //format allows is 0.01 ºC.)
      tempDegC = tempDegC/100; 

      var thisZigbeeDevice = DEVICES[nwkAddr.toString()+endPoint.toString()+RPCS_TEMP_READING];      

      if(thisZigbeeDevice) {
        this.log.info('emitting temp data for ZigbeeDevice: ' +thisZigbeeDevice.nwkAddr +':' +thisZigbeeDevice.endPoint +' tempDegC:' +tempDegC);
        thisZigbeeDevice.ninja.emit('data',tempDegC.toString())       
      }
      else
      {
        this.log.info('ZigBeeClient.prototype.processData[RPCS_TEMP_READING]: ZigbeeDevice ' +nwkAddr.toString()+endPoint.toString()+RPCS_TEMP_READING +' not defined.');
      };
      break;            
      
   case RPCS_ZONESTATE_CHANGE:

      var nwkAddr=0;
      var endPoint;      

      this.log.info('ZigBeeClient.prototype.processData[RPCS_ZONESTATE_CHANGE]');
      
      msgLen = msg[msgPtr + SRPC_CMD_LEN_POS] + 2;
      //index passed len, cmd ID and status
      msgPtr+=2;

      //Get the NwkAddr
      for (var i=0; i < 2; i++, msgPtr++) {
        //javascript does not support unsigned so use a bigger container
        //to avoid conversion issues
        var nwkAddrTemp = (msg[msgPtr] & 0xff);
        nwkAddr += (nwkAddrTemp << (8 * i));
      }
      this.log.debug('ZigBeeClient.prototype.processData[RPCS_ZONESTATE_CHANGE]: nwkAddr ' +nwkAddr);
       
      //Get the EndPoint
      endPoint = msg[msgPtr++];
      this.log.debug('ZigBeeClient.prototype.processData[RPCS_ZONESTATE_CHANGE]: endPoint ' +endPoint);

      //Get the zoneState
      var zoneState=0;
      for (var i=0; i < 4; i++, msgPtr++) {
        //javascript does not support unsigned so use a bigger container
        //to avoid conversion issues
        var zoneStateTemp = (msg[msgPtr] & 0xff);
        zoneState += (zoneStateTemp << (8 * i));
        this.log.debug('ZigBeeClient.prototype.processData[RPCS_ZONESTATE_CHANGE]: power: ' +zoneState +' zoneState:' +zoneState);
      }                  
      
      var thisZigbeeDevice = DEVICES[nwkAddr.toString()+endPoint.toString()+RPCS_ZONESTATE_CHANGE];      

      this.log.info('Received zoneState for ZigbeeDevice: ' +thisZigbeeDevice.nwkAddr +':' +thisZigbeeDevice.endPoint +':' +zoneState );
      
      
      var alarmAction = 0;
      
      
      if(thisZigbeeDevice) {
              
        //---------------- figure out what needs to be done -------------------
        
        if(zoneState == 0x1) //alarm1 triggered
        {
          alarmAction = 1; //start alarm
        }
        else if(zoneState ==  0x2) //alarm2 triggered
        {          
          alarmAction = 1; //start alarm                                  
        }      
        else if(zoneState = 0x4) //tamper triggered
        {
          alarmAction = 2; //short alarm                          
        }  
        else if(zoneState == 0x8) //low battery
        {
          alarmAction = 3; //pulse alarm                                  
        }     
        else if(zoneState == 0x10) //Supervision reports
        {
          //This bit indicates whether the Zone issues periodic Zone Status Change
          //Notification commands. The CIE device may use these periodic reports as an
          //indication that a zone is operational. Zones that do not implement the periodic
          //reporting are required to set this bit to zero (the CIE will know not to interpret the
          //lack of reports as a problem).
          alarmAction = 2; //short alarm                                   
        }     
        else if(zoneState == 0x20) //Restore reports
        {
          //This bit indicates whether or not a Zone Status Change Notification
          //command will be sent to indicate that an alarm is no longer present. Some Zones
          //do not have the ability to detect that alarm condition is no longer present, they
          //only can tell that an alarm has occurred. These Zones must set the "Restore" bit to
          //zero, indicating to the CIE not to look for alarm-restore notifications.           
          alarmAction = 2; //short alarm                  
        }     
        else if(zoneState == 0x40) //"Touble"
        {
          alarmAction = 3; //pulse alarm                             
        }
        else if(zoneState == 0x80) //AC Main Fault
        {
          alarmAction = 3; //pulse alarm                             
        }
        else if(zoneState == 0x80) //AC Main Fault
        {
          alarmAction = 3; //pulse alarm                             
        }
        else
        {
          alarmAction = 0; //stop alarm 
        }
           
        //---------------- do it -------------------                        
        if(alarmAction == 0) //stop alarm
        {
          this.log.info('emitting zoneState data for ZigbeeDevice: ' +thisZigbeeDevice.nwkAddr +':' +thisZigbeeDevice.endPoint +':' +zoneState );
          thisZigbeeDevice.ninja.emit('data','0')                                   
        }                 
        else if(alarmAction == 1) //start alarm
        {
          this.log.info('emitting zoneState data for ZigbeeDevice: ' +thisZigbeeDevice.nwkAddr +':' +thisZigbeeDevice.endPoint +':' +zoneState );
          thisZigbeeDevice.ninja.emit('data','1')                                   
        }           
        else if(alarmAction == 2) //short alarm
        {
          this.log.info('emitting alarm data for ZigbeeDevice: ' +thisZigbeeDevice.nwkAddr +':' +thisZigbeeDevice.endPoint +':1' );
          thisZigbeeDevice.ninja.emit('data','1')     

          setTimeout(function(){
            thisZigbeeDevice.ninja.emit('data', '0')
          },2000);                                          
        }           
        else if(alarmAction == 3) //pulse alarm (low battery or other issue)
        {
          this.log.info('emitting zoneState data for ZigbeeDevice: ' +thisZigbeeDevice.nwkAddr +':' +thisZigbeeDevice.endPoint +':' +zoneState );
          thisZigbeeDevice.ninja.emit('data','1')    
          
          var state = '1';
          clearInterval(this._iv);
          this._iv = setInterval(function(){
            
            if(state == '1')
              state = '0';
            else
              state = '1';
              
            thisZigbeeDevice.ninja.emit('data', state)
          },5000);                                         
        }                                                                   
      }
      else 
      {
        this.log.info('ZigBeeClient.prototype.processData[RPCS_ZONESTATE_CHANGE]: ZigbeeDevice not defined.');
      };              
      
      
     break;
     
    default:
      msgLen = 0;
      break;
  };
  return msgLen;
};

/**
 * Processes the RPCS_NEW_ZLL_DEVICE received from the SRPC connection.
 *
 * @param  {String} msg    Data received
 * @param  {Number} msgPtr Number of bytes processed
 * @fires ZigbeeClient#device instance of ZigbeeDevice on new device found.
 */
ZigBeeClient.prototype.processNewDevice = function(msg, msgPtr) {

  var profileId=0, deviceId=0, nwkAddr=0;
  var endPoint;
  var Type = {};
  var Name = {};   
  var numTypes = 0;
  var numClusters = {};

  //var Cluster = [[0,0,0,0,],[0,0,0,0],[0,0,0,0],[0,0,0,0,]]; 
  var Cluster = new Array();
  Cluster[0] = new Array();
  Cluster[0][0] = 0;
  Cluster[0][1] = 0;
  Cluster[0][2] = 0;
  Cluster[0][3] = 0;
  Cluster[1] = new Array();
  Cluster[1][0] = 0;
  Cluster[1][1] = 0;
  Cluster[1][2] = 0;
  Cluster[1][3] = 0;
  Cluster[2] = new Array();
  Cluster[2][0] = 0;
  Cluster[2][1] = 0;
  Cluster[2][2] = 0;
  Cluster[2][3] = 0;
  Cluster[3] = new Array();
  Cluster[3][0] = 0;
  Cluster[3][1] = 0;
  Cluster[3][2] = 0;
  Cluster[3][3] = 0;
  			
  Cluster[0][0] = 0;
  Type[0] = "";
  Name[0] = ""; 
    
  msgLen = msg[msgPtr + SRPC_CMD_LEN_POS] + 2;
  //index passed len, cmd ID and status
  msgPtr+=2;

  this.log.debug('ZigBeeClient.prototype.processNewDevice++');

  //Get the NwkAddr
  for (var i=0; i < 2; i++, msgPtr++) {
    //javascript does not support unsigned so use a bigger container
    //to avoid conversion issues
    var nwkAddrTemp = (msg[msgPtr] & 0xff);
    nwkAddr += (nwkAddrTemp << (8 * i));
  }
  this.log.debug('ZigBeeClient.prototype.processData: nwkAddr ' +nwkAddr);

  //Get the EndPoint
  endPoint = msg[msgPtr++];
  this.log.debug('ZigBeeClient.prototype.processData: endPoint ' +endPoint);

  //Get the ProfileId
  for (var i=0; i < 2; i++, msgPtr++) {
    //javascript does not support unsigned so use a bigger container
    //to avoid conversion issues
    var profileIdTemp = (msg[msgPtr] & 0xff);
    profileId += (profileIdTemp << (8 * i));
  }
  this.log.debug('ZigBeeClient.prototype.processData: profileId ' +profileId);

  //Get the DeviceId
  for (var i=0; i < 2; i++, msgPtr++) {
    //javascript does not support unsigned so use a bigger container
    //to avoid conversion issues
    var deviceIdTemp = (msg[msgPtr] & 0xff);
    deviceId += (deviceIdTemp << (8 * i));
  }
  this.log.debug('ZigBeeClient.prototype.processData: deviceId ' +deviceId);

  // Would be better to get the device name from the device!
  //CHECK PROFILE ID AS WELL, HUE USES ZLL PROFILE ID!!!!
  if(profileId == 0xc05e) //ZLL
  {
    switch (deviceId)
    {
  		case (0x0000):
  		{
  			//An On off Light
  			Type[0] = "ZLL On/Off Light";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZllDeviceIdx+1) + ": ZLL On/Off Light";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
  		case (0x0010):
  		{
  			//An On Off Plug-In unit
  			Type[0] = "ZLL On/Off Plug";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZllDeviceIdx+1) + ": ZLL On/Off Plug";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
  		case (0x0100):
  		{
  			//A Dimmable Light
  			Type[0] = "ZLL Dimmable Light";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZllDeviceIdx+1) + ": ZLL Dimmable Light";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
  		case (0x0110):
  		{
  			//A Dimmable Plug-In unit
  			Type[0] = "ZLL Dimmable Plug";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZllDeviceIdx+1) + ": ZLL Dimmable Plug";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
  		case (0x0200):
  		{
  			//A Color Light
  			Type[0] = "ZLL Color Light";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZllDeviceIdx+1) + ": ZLL Color Light";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
  		case (0x0210):
  		{
  			//An Extended Color Light
  			Type[0] = "ZLL Extended Color Light";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZllDeviceIdx+1) + ": ZLL Extended Color Light";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
  		case (0x0220):
  		{
  			//An Color Temp Light
  			Type[0] = "ZLL Color Temp Light";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZllDeviceIdx+1) + ": ZLL Color Temp Light";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
  		case (0x0800):
  		{
  			//A Color Controller
  			Type[0] = "ZLL Color Controller";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZllDeviceIdx+1) + ": ZLL Color Controller";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
  		case (0x0810):
  		{
  			//A Color Scene Controller
  			Type[0] = "ZLL Color Scene Controller";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZllDeviceIdx+1) + ": ZLL Color Scene Controller";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
  		case (0x0820):
  		{
  			//A Dimmable Scene Controller
  			Type[0] = "ZLL Dimmable Scene Controller";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZllDeviceIdx+1) + ": ZLL Dimmable Scene Controller";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
  		case (0x0830):
  		{
  			//A Dimmable Controller
  			Type[0] = "ZLL Dimmable Controller";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZllDeviceIdx+1) + ": ZLL Dimmable Controller";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
  		case (0x0840):
  		{
  			//A Control Bridge
  			Type[0] = "ZLL Control Bridge";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZllDeviceIdx+1) + ": ZLL Control Bridge";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
  		case (0x0850):
  		{
  			//An On/Off Sensor
  			Type[0] = "ZLL On/Off Sensor";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZllDeviceIdx+1) + ": On/Off Sensor";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
      default:
      {
        Type[0] = "Unknown Device";
        Name[0] ="Unknown";
        numTypes = 0;
  			break;
      }
    }
  }
  else if(profileId == 0x0104) //ZLL
  {
    switch (deviceId)
    {
  		case (0x0000):
  		{
  			Type[0] = "On/Off Switch";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZigBeeDeviceIdx+1) + ": " + "On/Off Switch";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
  		case (0x0001):
  		{
  			Type[0] = "Level Control Switch";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZigBeeDeviceIdx+1) + ": " + "Level Control Switch";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
  		case (0x0002):
  		{
  			Type[0] = "On/Off Output";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZigBeeDeviceIdx+1) + ": " + "On/Off Output";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
  		case (0x0003):
  		{
  			Type[0] = "Level Controllable Output";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZigBeeDeviceIdx+1) + ": " + "Level Controllable Output";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
  		case (0x0004):
  		{
  			Type[0] = "Scene Selector";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZigBeeDeviceIdx+1) + ": " + "Scene Selector";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
  		case (0x0005):
  		{
  			Type[0] = "Configuration Tool";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZigBeeDeviceIdx+1) + ": " + "Configuration Tool";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
  		case (0x0006):
  		{
  			Type[0] = "Remote Control";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZigBeeDeviceIdx+1) + ": " + "Remote Control";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
  		case (0x0007):
  		{
  			Type[0] = "Combined Interface";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZigBeeDeviceIdx+1) + ": " + "Combined Interface";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
  		case (0x0008):
  		{
  			Type[0] = "Range Extender";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZigBeeDeviceIdx+1) + ": " + "Range Extender";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
  		case (0x0009):
  		{
  			Type[0] = "Mains Power Outlet";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZigBeeDeviceIdx+1) + ": " + "Mains Power Outlet";
  			Cluster[0][0] = RPCS_POWER_READING; 
  			numClusters[0] = 1; 			  			
  			numTypes++;
  			
  			//need to check cluster to see if this implementation of a smart plug has a power meter,
  			//For now just assume it has
  			Type[1] = "Power Meter";
  			//set a default name that can be renamed later and stored in the hub
  			Name[1] = (ZigBeeDeviceIdx+1) + ": " + "Power Meter";
  			Cluster[1][0] = RPCS_POWER_READING; 
  			numClusters[1] = 1; 			  			
  			numTypes++;
  			
  			break;
  		}
  		case (0x000A):
  		{
  			Type[0] = "Door Lock";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZigBeeDeviceIdx+1) + ": " + "Door Lock";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
  		case (0x000B):
  		{
  			Type[0] = "Door Lock Controller";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZigBeeDeviceIdx+1) + ": " + "Door Lock Controller";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
   		case (0x000C):
  		{
  			Type[0] = "Simple Sensor";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZigBeeDeviceIdx+1) + ": " + "Simple Sensor";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
   		case (0x000D):
  		{
  			Type[0] = "Consumption Awareness Device";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZigBeeDeviceIdx+1) + ": " + "Consumption Awareness Device";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
   		case (0x0050):
  		{
  			Type[0] = "Home Gateway";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZigBeeDeviceIdx+1) + ": " + "Home Gateway";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
   		case (0x0051):
  		{
  			Type[0] = "Smart plug";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZigBeeDeviceIdx+1) + ": " + "Smart plug";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
   		case (0x0052):
  		{
  			Type[0] = "White Goods";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZigBeeDeviceIdx+1) + ": " + "White Goods";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
   		case (0x0053):
  		{
  			Type[0] = "Meter Interface";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZigBeeDeviceIdx+1) + ": " + "Meter Interface";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
   		case (0x0100):
  		{
  			Type[0] = "On/Off Light";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZigBeeDeviceIdx+1) + ": " + "On/Off Light";
  			numTypes = 1;
  			numClusters[0] = 1;
  		  Cluster[0][0] = RPCS_GET_DEV_STATE_RSP;
  			break;
  		}
   		case (0x0101):
  		{
  			Type[0] = "Dimmable Light";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZigBeeDeviceIdx+1) + ": " + "Dimmable Light";
  			numTypes = 1;
  			numClusters[0] = 2;
  		  Cluster[0][0] = RPCS_GET_DEV_STATE_RSP;
  		  Cluster[0][1] = RPCS_GET_DEV_LEVEL_RSP;
  			break;
  		}
   		case (0x0102):
  		{
  			Type[0] = "Color Dimmable Light";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZigBeeDeviceIdx+1) + ": " + "Color Dimmable Light";
  			numTypes = 1;
  			numClusters[0] = 4;
  		  Cluster[0][0] = RPCS_GET_DEV_STATE_RSP;
  		  Cluster[0][1] = RPCS_GET_DEV_LEVEL_RSP;
  		  Cluster[0][2] = RPCS_GET_DEV_HUE_RSP;
  		  Cluster[0][3] = RPCS_GET_DEV_SAT_RSP;
  		  
  			break;
  		}
   		case (0x0103):
  		{
  			Type[0] = "On/Off Light Switch";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZigBeeDeviceIdx+1) + ": " + "On/Off Light Switch";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
   		case (0x0104):
  		{
  			Type[0] = "Dimmer Switch";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZigBeeDeviceIdx+1) + ": " + "Dimmer Switch";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
   		case (0x0105):
  		{
  			Type[0] = "Color Dimmer Switch";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZigBeeDeviceIdx+1) + ": " + "Color Dimmer Switch";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
   		case (0x0106):
  		{
  			Type[0] = "Light Sensor";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZigBeeDeviceIdx+1) + ": " + "Light Sensor";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
   		case (0x0107):
  		{
  			Type[0] = "Occupancy Sensor";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZigBeeDeviceIdx+1) + ": " + "Occupancy Sensor";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
   		case (0x0200):
  		{
  			Type[0] = "Shade";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZigBeeDeviceIdx+1) + ": " + "Shade";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
   		case (0x0201):
  		{
  			Type[0] = "Shade Controller";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZigBeeDeviceIdx+1) + ": " + "Shade Controller";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
   		case (0x0202):
  		{
  			Type[0] = "Window Covering Device";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZigBeeDeviceIdx+1) + ": " + "Window Covering Device";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
   		case (0x0203):
  		{
  			Type[0] = "Window Covering Controller";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZigBeeDeviceIdx+1) + ": " + "Window Covering Controller";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
   		case (0x0300):
  		{
  			Type[0] = "Heating/Cooling Unit";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZigBeeDeviceIdx+1) + ": " + "Heating/Cooling Unit";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
      case (0x0301):
  		{
  			Type[0] = "Thermostat";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZigBeeDeviceIdx+1) + ": " + "Thermostat";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
      case (0x0302):
  		{
  			Type[0] = "Temperature Sensor";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZigBeeDeviceIdx+1) + ": " + "Temperature Sensor";  		
  			numTypes = 1;
  			Cluster[0][0] = RPCS_TEMP_READING;
  			numClusters[0] = 1;
  			break;
  		}
      case (0x0303):
  		{
  			Type[0] = "Pump";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZigBeeDeviceIdx+1) + ": " + "Pump";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
      case (0x0304):
  		{
  			Type[0] = "Pump Controller";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZigBeeDeviceIdx+1) + ": " + "Pump Controller";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
      case (0x0305):
  		{
  			Type[0] = "Pressure Sensor";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZigBeeDeviceIdx+1) + ": " + "Pressure Sensor";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
      case (0x0306):
  		{
  			Type[0] = "Flow Sensor";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZigBeeDeviceIdx+1) + ": " + "Flow Sensor";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
      case (0x0307):
  		{
  			Type[0] = "Mini Split AC";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZigBeeDeviceIdx+1) + ": " + "Mini Split AC";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
  		//reserved in Zigbee, but used by some vendors for a device with temp and huniditty sensing.
  		//This is a classic example of why we need to search through clusters for devices.
  		//For now just assume this is the RS-23ZB with Temp and Humidity sensing
      case (0x03FE):
  		{
  			Type[0] = "Temperature Sensor";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZigBeeDeviceIdx+1) + ": " + "Temperature Sensor";
  			Cluster[0][0] = RPCS_TEMP_READING;  			        			
  			numClusters[0] = 1;
  			numTypes++;
 
   			Type[1] = "Humidity Sensor";
  			//set a default name that can be renamed later and stored in the hub
  			Name[1] = (ZigBeeDeviceIdx+1) + ": " + "Humidity Sensor";
  			Cluster[1][0] = RPCS_HUMID_READING;
  			numClusters[1] = 1;
  			numTypes++;
  			
  			break;  			
  		}    		
      case (0x0400):
  		{
  			Type[0] = "IAS Control and Indicating Equipment ";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZigBeeDeviceIdx+1) + ": " + "IAS Control and Indicating Equipment ";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
      case (0x0401):
  		{
  			Type[0] = "IAS Ancillary Control Equipment";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZigBeeDeviceIdx+1) + ": " + "IAS Ancillary Control Equipment";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
      case (0x0402):
  		{
  			Type[0] = "IAS Zone";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZigBeeDeviceIdx+1) + ": " + "IAS Zone";
  			numTypes = 1;
  			Cluster[0][0] = RPCS_ZONESTATE_CHANGE;
  			numClusters[0] = 1;
  			break;
  		}
      case (0x0403):
  		{
  			Type[0] = "IAS Warning Device";
  			//set a default name that can be renamed later and stored in the hub
  			Name[0] = (ZigBeeDeviceIdx+1) + ": " + "IAS Warning Device";
  			numTypes = 1;
  			Cluster[0][0] = 0;
  			numClusters[0] = 1;
  			break;
  		}
      default:
      {
        //TODO Go on to process the clusters supported if the device Type[0] is not known
        Type[0] ="Unknown Device";
        Name[0] ="Unknown";
        numTypes = 1;
  			break;
      }
    }
  }
  
  this.log.debug('ZigBeeClient.prototype.processNewDevice: numTypes:', +numTypes);  
  for( i =0; i < numTypes; i++)
  {
    this.log.debug('ZigBeeClient.prototype.processNewDevice: numClusters['+i+']:', +numClusters[i]);  
    for( j =0; j < numClusters[i]; j++)
    {     
      // A new device has been found      
      var device = new ZigbeeDevice(this.log, profileId, deviceId, nwkAddr, endPoint, Type[i], Name[i]);
      DEVICES[nwkAddr.toString()+endPoint.toString()+Cluster[i][j]] = device;
      
      this.log.info('ZigBeeClient.prototype.processNewDevice: ' +nwkAddr.toString()+endPoint.toString()+Cluster[i][j]);
      
      this.emit('device', device);       
    } 
  }
           
};

/**
 * Advises the SRPC server to discover devices
 *
 * @fires ZigbeeClient#data data to be written to the SRPC connection
 */
ZigBeeClient.prototype.discoverDevices = function() {
  var msg = new Buffer(4);
  var msgIdx;
  msg[SRPC_CMD_ID_POS] = RPCS_GET_DEVICES;
  msg[SRPC_CMD_LEN_POS] = 2;

  this.log.debug('discoverDevices');

  this.emit('data',msg);
};

ZigBeeClient.prototype.end = function() {};
ZigBeeClient.prototype.destroy = function() {};